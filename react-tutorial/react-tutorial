
# Tic-tac-toe

## What is React

React is a declarative, efficient, and flexible
Javascript library for building user interfaces.

React has a few different kinds of components,
but we'll start with React.Component.

class ShoppingList extends React.Component {
  render() {
    return (
      <div className="shopping-list">
        <h1>Shopping List for {this.props.name}</h1>
        <ul>
          <li>Instagram</li>
          <li>WhapsApp</li>
          <li>Oculus</li>
        </ul>
      </div>
    )
  }
}


Components tell React what to render - then React
will efficiently update and render just the right
components when your data changes.

Here, ShoppingList is a React component class,
or React component type. A component takes in parameters,
called props, and returns a hierarchy of views to display
via the render method.

Render return React element, which is a lightweight
description of what to render.

The shoppingList component only render built-in DOM
components, but you can compose custom React components just as easily,
by writing <ShoppingList />. Each component is encapsulated so it can
operate independently, which allows you to build complex UIs out of
simple components.



## Get started

3 components :
- Square
- Board
- Game

The Square component renders a single <button/>,

the Board renders 9 squares, and the Game component renders a board with
some placeholders that we'll fill in later.



## Passing Data Through Props

Let's try to pass some data from the Board component to the Square:

class Board extends Component {
  renderSquare(i) {
    return <Square value={i} />
  }
}

Then change Square's render method to show that value by
replacing {/* */} with {this.props.value}:

class Square extends Component {
  render() {
    return (
      <button className="square">
       {this.props.value}
      </button>
    )
  }
}



## An Interactive Component

Let's make the Square component fill in an "X"
when you click it. Try changing the button
tag returned in the render() function of the
Square like this:

class Square extends Component {
  render() {
    return (
      <button className="square" onClick={() => alert('click')}>
        {this.props.value}
      </button>
    )
  }
}

Doing {alert('click')} would alert immediately instead of when
the button is clicked.

React components can have state by setting this.state in the
constructor, which should be considered private to the component.

Let's store the current value of the square in state,
and change it when the square is clicked.


First, add a constructor to the class to initialize the state:

class Square extends Component {
  constructor(props) {
    super(props)
    this.state = {
      value: null,
    }
  }

  render() {
    return (
      <button className="square" onClick{() => alert('click')}>
        {this.props.value}
      </button>
    )
  }
}

In Javascript classes, you need to explicitly call super();
when defining the constructor of a subclass.

Now change the Square render method to display the value from
the current state, and to toggle it on click:

- Replace this.props.value with this.state.value inside the button tag.

- Replace the () => alert() event handler with () => this.setState({value: 'X'}).


class Square extends Component {
  constructor(props) {
    super(props)
    this.state = {
      value: null,
    }
  }

  render() {
    return (
      <button className="square" onClick={() => this.setState({value: 'X'})}>
        {this.state.value}
      </button>
    )
  }
}


Whenever this.setState is called, an update to the component is
scheduled, causing React to merge in the passed state updated and
rerender the component along with its descendants.

When the component rerenders, this.state.value will be 'X'
so you'll see an X in the grid.

If you click on any square, an X should show up in it.



## Lifting State Up

We now have the basic building blocks for a tic-tac-toe game.
But right now, the state is encapsulated in each Square component.

To make a fully-working game, we now need to check if
one player has wont the game, and alternate placing X and O
in the squares. To check if someone has won, we'll need to have
the value of all 9 squares in one place, rather than split up
accross the Square components.


The best solution here is to store this state in the Board
component instead of in each Square - and the Board component can tell
each Square what to display, like how we made each display its index earlier.

When you want to aggregate data from multiple children or to have
two child components communicate with each other,
move the state upwards so that it lives in the parent component.

The parent can then pass the state back down to the children via props,
so that the children components are always in sync with each other and with
the parent.

class Board extends Component {
  constructor(props) {
    super(props)
    this.state = {
      squares: Array(9).fill(null),
    }
  }
  renderSquare(i) {
  return <Square value={i} />;
}

render() {
  const status = 'Next player: X';

  return (
      <div>
        <div className="status">{status}</div>
        <div className="board-row">
          {this.renderSquare(0)}
          {this.renderSquare(1)}
          {this.renderSquare(2)}
        </div>
        <div className="board-row">
          {this.renderSquare(3)}
          {this.renderSquare(4)}
          {this.renderSquare(5)}
        </div>
        <div className="board-row">
          {this.renderSquare(6)}
          {this.renderSquare(7)}
          {this.renderSquare(8)}
        </div>
      </div>
    );
  }
}

We'll fill it in later so that a board looks something like

[
  'O', null, 'X',
  'X', 'X', 'O',
  'O', null, null,
]

Board's renderSquare method currently looks like this:

renderSquare(i) {
  return <Square value={i} />
}


Modify it to pass a value prop to Square.

renderSquare(i) {
  return <Square value={this.state.squares[i]} />;
}
